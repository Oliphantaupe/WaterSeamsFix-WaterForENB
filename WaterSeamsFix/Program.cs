// Water Seams Fix - Water for ENB - Synthesis Patcher for Skyrim Special Edition
// Forwards Water for ENB water edits to win conflicts with other mods.

using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using WaterSeamsFix.Settings;

namespace WaterSeamsFix;

public class Program
{
    private const string OutputPluginName = "Water Seams Fix.esp";
    private const int CompressionFlag = 0x00040000;

    private static readonly ModKey BaseEsm = ModKey.FromNameAndExtension("Water for ENB.esm");

    // Mods that are automatically skipped (never processed)
    private static readonly HashSet<string> AutoSkippedMods = new(StringComparer.OrdinalIgnoreCase)
    {
        "Synthesis.esp",
        "DynDOLOD.esm",
        "DynDOLOD.esp",
        "Occlusion.esp",
        "Water Seams Fix.esp"
    };

    private static Lazy<Settings.Settings> _settings = null!;
    private static bool _verbose;

    public static async Task<int> Main(string[] args)
    {
        return await SynthesisPipeline.Instance
            .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
            .SetAutogeneratedSettings(
                nickname: "Settings",
                path: "settings.json",
                out _settings)
            .SetTypicalOpen(GameRelease.SkyrimSE, OutputPluginName)
            .Run(args);
    }

    public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
    {
        var settings = _settings.Value;
        _verbose = settings.VerboseOutput;

        Console.WriteLine();
        Console.WriteLine("==============================================");
        Console.WriteLine("  WATER FOR ENB PATCHER");
        Console.WriteLine("==============================================");
        Console.WriteLine();

        // Build user skip list
        var userSkipMods = settings.ModsToSkip
            .Select(m => m.FileName.String)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        // Find W4ENB mods
        var w4enbMods = new List<(ModKey Key, ISkyrimModGetter Mod)>();

        // Handle base ESM based on settings (only relevant for Shades of Skyrim users)
        if (settings.IncludeBaseEsm || settings.WaterForEnbPlugin.IsNull || settings.WaterForEnbPlugin.Equals(BaseEsm))
        {
            var baseMod = FindMod(state, BaseEsm);
            if (baseMod != null)
            {
                w4enbMods.Add((BaseEsm, baseMod));
                Console.WriteLine($"  Found: {BaseEsm.FileName}");
            }
        }

        // Add user-selected main plugin if different from base ESM
        if (!settings.WaterForEnbPlugin.IsNull && !settings.WaterForEnbPlugin.Equals(BaseEsm))
        {
            var mainMod = FindMod(state, settings.WaterForEnbPlugin);
            if (mainMod != null)
            {
                w4enbMods.Add((settings.WaterForEnbPlugin, mainMod));
                Console.WriteLine($"  Found: {settings.WaterForEnbPlugin.FileName}");
            }
        }

        if (w4enbMods.Count == 0)
        {
            Console.WriteLine("ERROR: Water for ENB not found in load order.");
            Console.WriteLine("Make sure Water for ENB is installed and enabled.");
            return;
        }

        Console.WriteLine();

        // Find all mods that depend on W4ENB
        var w4enbModKeys = w4enbMods.Select(x => x.Key).ToHashSet();
        var modsToProcess = new List<(ModKey Key, ISkyrimModGetter Mod)>(w4enbMods);

        foreach (var listing in state.LoadOrder.PriorityOrder)
        {
            if (listing.Mod == null) continue;
            var modKey = listing.ModKey;

            // Skip if it's a W4ENB mod itself
            if (w4enbModKeys.Contains(modKey)) continue;

            // Skip auto-skipped mods
            if (AutoSkippedMods.Contains(modKey.FileName.String)) continue;

            // Skip user-specified mods
            if (userSkipMods.Contains(modKey.FileName.String))
            {
                Console.WriteLine($"  [SKIP] {modKey.FileName} (user excluded)");
                continue;
            }

            // Check if mod depends on W4ENB
            bool dependsOnW4ENB = listing.Mod.MasterReferences
                .Any(master => w4enbModKeys.Contains(master.Master));

            if (dependsOnW4ENB)
                modsToProcess.Add((modKey, listing.Mod));
        }

        Console.WriteLine($"Processing {modsToProcess.Count} mod(s):");
        foreach (var (key, _) in modsToProcess)
        {
            bool isW4enb = w4enbModKeys.Contains(key);
            Console.WriteLine($"  {(isW4enb ? "[W4ENB]" : "[PATCH]")} {key.FileName}");
        }
        Console.WriteLine();

        // Track statistics
        int cellsPatched = 0;
        int worldspacesPatched = 0;
        var patchedByMod = new Dictionary<string, int>();
        var skippedCorrupt = new List<string>();

        // Process each mod
        foreach (var (modKey, mod) in modsToProcess)
        {
            string modName = modKey.FileName.String;

            try
            {
                int modPatches = 0;

                // Process interior cells
                foreach (var cellBlock in mod.Cells.Records)
                {
                    foreach (var subBlock in cellBlock.SubBlocks)
                    {
                        foreach (var cell in subBlock.Cells)
                        {
                            if (TryPatchCell(cell, state, w4enbModKeys, modName))
                            {
                                modPatches++;
                                cellsPatched++;
                            }
                        }
                    }
                }

                // Process worldspaces and exterior cells
                foreach (var worldspace in mod.Worldspaces)
                {
                    if (TryPatchWorldspace(worldspace, state, w4enbModKeys, modName))
                        worldspacesPatched++;

                    foreach (var block in worldspace.SubCells)
                    {
                        foreach (var subBlock in block.Items)
                        {
                            foreach (var cell in subBlock.Items)
                            {
                                if (TryPatchCell(cell, state, w4enbModKeys, modName))
                                {
                                    modPatches++;
                                    cellsPatched++;
                                }
                            }
                        }
                    }
                }

                if (modPatches > 0)
                    patchedByMod[modName] = modPatches;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  Warning: Error processing {modName}: {ex.Message}");
                skippedCorrupt.Add(modName);
            }
        }

        // Clear compression flags
        int decompressed = ClearCompressionFlags(state.PatchMod);

        // Summary
        Console.WriteLine("----------------------------------------------");
        Console.WriteLine("  RESULTS");
        Console.WriteLine("----------------------------------------------");
        Console.WriteLine();

        if (patchedByMod.Count > 0)
        {
            Console.WriteLine("Cells patched by source mod:");
            foreach (var kvp in patchedByMod.OrderByDescending(x => x.Value))
                Console.WriteLine($"  {kvp.Value,5} - {kvp.Key}");
            Console.WriteLine();
        }

        Console.WriteLine($"Total cells patched: {cellsPatched}");
        Console.WriteLine($"Worldspaces patched: {worldspacesPatched}");

        if (decompressed > 0)
            Console.WriteLine($"Records decompressed: {decompressed}");

        if (skippedCorrupt.Count > 0)
        {
            Console.WriteLine();
            Console.WriteLine($"Mods with errors (skipped): {skippedCorrupt.Count}");
            foreach (var mod in skippedCorrupt)
                Console.WriteLine($"  - {mod}");
        }

        Console.WriteLine();

        if (cellsPatched > 0 || worldspacesPatched > 0)
            Console.WriteLine("Done! Water for ENB changes have been forwarded.");
        else
            Console.WriteLine("Done! No conflicts found - W4ENB is already winning.");

        Console.WriteLine();
    }

    private static ISkyrimModGetter? FindMod(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, ModKey modKey)
    {
        foreach (var listing in state.LoadOrder.PriorityOrder)
        {
            if (listing.ModKey.Equals(modKey) && listing.Mod != null)
                return listing.Mod;
        }
        return null;
    }

    private static bool TryPatchCell(
        ICellGetter sourceCell,
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        HashSet<ModKey> w4enbModKeys,
        string sourceModName)
    {
        try
        {
            // Try to resolve the winning override for this cell
            if (!state.LinkCache.TryResolveContext<ICell, ICellGetter>(sourceCell.FormKey, out var winningContext))
                return false;

            var winningCell = winningContext.Record;
            var winnerModKey = winningContext.ModKey;

            // If W4ENB is already winning, no patch needed
            if (w4enbModKeys.Contains(winnerModKey))
                return false;

            // Check if any water field differs between source (W4ENB/patch) and winner
            bool waterDiffers = !FormLinksEqual(sourceCell.Water, winningCell.Water);
            bool envMapDiffers = sourceCell.WaterEnvironmentMap != winningCell.WaterEnvironmentMap;
            bool heightDiffers = sourceCell.Flags.HasFlag(Cell.Flag.HasWater) &&
                                 sourceCell.WaterHeight != winningCell.WaterHeight;
            bool flagDiffers = sourceCell.Flags.HasFlag(Cell.Flag.HasWater) &&
                               !winningCell.Flags.HasFlag(Cell.Flag.HasWater);

            if (!waterDiffers && !envMapDiffers && !heightDiffers && !flagDiffers)
                return false;

            // Create patch record
            var patchCell = winningContext.GetOrAddAsOverride(state.PatchMod);

            if (waterDiffers && !sourceCell.Water.IsNull)
                patchCell.Water.SetTo(sourceCell.Water);

            if (envMapDiffers && sourceCell.WaterEnvironmentMap != null)
                patchCell.WaterEnvironmentMap = sourceCell.WaterEnvironmentMap;

            if (heightDiffers)
                patchCell.WaterHeight = sourceCell.WaterHeight;

            if (flagDiffers)
                patchCell.Flags |= Cell.Flag.HasWater;

            if (_verbose)
            {
                string editorId = sourceCell.EditorID ?? sourceCell.FormKey.ToString();
                Console.WriteLine($"    Patched cell {editorId} (from {sourceModName})");
            }

            return true;
        }
        catch (Exception ex)
        {
            if (_verbose)
                Console.WriteLine($"    Error patching cell {sourceCell.FormKey}: {ex.Message}");
            return false;
        }
    }

    private static bool TryPatchWorldspace(
        IWorldspaceGetter sourceWorldspace,
        IPatcherState<ISkyrimMod, ISkyrimModGetter> state,
        HashSet<ModKey> w4enbModKeys,
        string sourceModName)
    {
        try
        {
            // Try to resolve the winning override for this worldspace
            if (!state.LinkCache.TryResolveContext<IWorldspace, IWorldspaceGetter>(sourceWorldspace.FormKey, out var winningContext))
                return false;

            var winningWorldspace = winningContext.Record;
            var winnerModKey = winningContext.ModKey;

            // If W4ENB is already winning, no patch needed
            if (w4enbModKeys.Contains(winnerModKey))
                return false;

            bool waterDiffers = !FormLinksEqual(sourceWorldspace.Water, winningWorldspace.Water);
            bool lodWaterDiffers = !FormLinksEqual(sourceWorldspace.LodWater, winningWorldspace.LodWater);

            if (!waterDiffers && !lodWaterDiffers)
                return false;

            var patchWorldspace = winningContext.GetOrAddAsOverride(state.PatchMod);

            if (waterDiffers && !sourceWorldspace.Water.IsNull)
                patchWorldspace.Water.SetTo(sourceWorldspace.Water);

            if (lodWaterDiffers && !sourceWorldspace.LodWater.IsNull)
                patchWorldspace.LodWater.SetTo(sourceWorldspace.LodWater);

            if (_verbose)
            {
                string editorId = sourceWorldspace.EditorID ?? sourceWorldspace.FormKey.ToString();
                Console.WriteLine($"    Patched worldspace {editorId} (from {sourceModName})");
            }

            return true;
        }
        catch (Exception ex)
        {
            if (_verbose)
                Console.WriteLine($"    Error patching worldspace {sourceWorldspace.FormKey}: {ex.Message}");
            return false;
        }
    }

    private static bool FormLinksEqual<T>(IFormLinkNullableGetter<T> a, IFormLinkNullableGetter<T> b)
        where T : class, IMajorRecordGetter
    {
        if (a.IsNull && b.IsNull) return true;
        if (a.IsNull || b.IsNull) return false;
        return a.FormKey.Equals(b.FormKey);
    }

    private static int ClearCompressionFlags(ISkyrimMod patchMod)
    {
        int count = 0;
        foreach (var record in patchMod.EnumerateMajorRecords())
        {
            if (record is IMajorRecord mutable && (mutable.MajorRecordFlagsRaw & CompressionFlag) != 0)
            {
                mutable.MajorRecordFlagsRaw &= ~CompressionFlag;
                count++;
            }
        }
        return count;
    }
}
